// <auto-generated>
//  This code was generated by the following tool on 2022-08-01 03:29:40 GMT+00:00:
//      https://github.com/bottlenoselabs/c2cs (v3.2.8.0)
//      
//  Changes to this file may cause incorrect behavior and will be lost if the code is
//      regenerated. To extend or add functionality use a partial class in a new file.
// </auto-generated>
// ReSharper disable All

#nullable enable
#pragma warning disable 1591
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using static bottlenoselabs.Theorafile.Runtime;

namespace bottlenoselabs
{
    public static unsafe partial class Theorafile
    {
        private const string LibraryName = "theorafile";

        #region API

        // Function @ theorafile.h:108:15
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void tf_close(OggTheora_File* file);

        // Function @ theorafile.h:113:15
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void tf_videoinfo(OggTheora_File* file, int* width, int* height, double* fps, th_pixel_fmt* fmt);

        // Function @ theorafile.h:128:15
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void tf_reset(OggTheora_File* file);

        // Function @ theorafile.h:162:14
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_setvideotrack(OggTheora_File* file, int ttrack);

        // Function @ theorafile.h:137:14
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_readvideo(OggTheora_File* file, CString buffer, int numframes);

        // Function @ theorafile.h:112:14
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_hasaudio(OggTheora_File* file);

        // Function @ theorafile.h:120:15
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void tf_audioinfo(OggTheora_File* file, int* channels, int* samplerate);

        // Function @ theorafile.h:111:14
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_hasvideo(OggTheora_File* file);

        // Function @ theorafile.h:150:14
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_setaudiotrack(OggTheora_File* file, int vtrack);

        // Function @ theorafile.h:127:14
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_eos(OggTheora_File* file);

        // Function @ theorafile.h:138:14
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_readaudio(OggTheora_File* file, float* buffer, int samples);

        // Function @ theorafile.h:104:14
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_fopen(CString fname, OggTheora_File* file);

        // Function @ theorafile.h:99:14
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_open_callbacks(void* datasource, OggTheora_File* file, tf_callbacks io);

        #endregion

        #region Types

        // FunctionPointer @ NoLocation
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr_Ulong_Ulong_VoidPtr_Ulong
        {
            public delegate* unmanaged<void*, ulong, ulong, void*, ulong> Pointer;
        }

        // FunctionPointer @ NoLocation
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr_Ogg_int64_t_Int_Int
        {
            public delegate* unmanaged<void*, ogg_int64_t, int, int> Pointer;
        }

        // FunctionPointer @ NoLocation
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr_Th_ycbcr_buffer_Int_Int_Void
        {
            public delegate* unmanaged<void*, th_ycbcr_buffer, int, int, void> Pointer;
        }

        // FunctionPointer @ NoLocation
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr_Int
        {
            public delegate* unmanaged<void*, int> Pointer;
        }

        // Struct @ theorafile.h:48:16
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct tf_callbacks
        {
            [FieldOffset(0)] // size = 8
            public FnPtr_VoidPtr_Ulong_Ulong_VoidPtr_Ulong read_func;

            [FieldOffset(8)] // size = 8
            public FnPtr_VoidPtr_Ogg_int64_t_Int_Int seek_func;

            [FieldOffset(16)] // size = 8
            public FnPtr_VoidPtr_Int close_func;
        }

        // Struct @ ogg.h:105:9
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-pc-windows-msvc (lib\ogg\ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-pc-windows-msvc (lib\ogg\ogg.h)
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct ogg_sync_state
        {
            [FieldOffset(0)] // size = 8
            public byte* data;

            [FieldOffset(8)] // size = 4
            public int storage;

            [FieldOffset(12)] // size = 4
            public int fill;

            [FieldOffset(16)] // size = 4
            public int returned;

            [FieldOffset(20)] // size = 4
            public int unsynced;

            [FieldOffset(24)] // size = 4
            public int headerbytes;

            [FieldOffset(28)] // size = 4
            public int bodybytes;
        }

        // Struct @ theoradec.h:142:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-pc-windows-msvc (lib\theora\theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-pc-windows-msvc (lib\theora\theoradec.h)
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct th_stripe_callback
        {
            [FieldOffset(0)] // size = 8
            public void* ctx;

            [FieldOffset(8)] // size = 8
            public th_stripe_decoded_func stripe_decoded;
        }

        // Struct @ codec.h:438:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 4)]
        public struct th_huff_code
        {
            [FieldOffset(0)] // size = 4
            public ogg_uint32_t pattern;

            [FieldOffset(4)] // size = 4
            public int nbits;
        }

        // Struct @ codec.h:142:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct th_img_plane
        {
            [FieldOffset(0)] // size = 4
            public int width;

            [FieldOffset(4)] // size = 4
            public int height;

            [FieldOffset(8)] // size = 4
            public int stride;

            [FieldOffset(16)] // size = 8
            public byte* data;
        }

        // Struct @ codec.h:409:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 464, Pack = 8)]
        public struct th_quant_info
        {
            [FieldOffset(0)] // size = 128
            public fixed byte _dc_scale[128]; // ogg_uint16_t[64]

            public Span<ogg_uint16_t> dc_scale
            {
                get
                {
                    fixed (th_quant_info* @this = &this)
                    {
                        var pointer = &@this->_dc_scale[0];
                        var span = new Span<ogg_uint16_t>(pointer, 64);
                        return span;
                    }
                }
            }

            [FieldOffset(128)] // size = 128
            public fixed byte _ac_scale[128]; // ogg_uint16_t[64]

            public Span<ogg_uint16_t> ac_scale
            {
                get
                {
                    fixed (th_quant_info* @this = &this)
                    {
                        var pointer = &@this->_ac_scale[0];
                        var span = new Span<ogg_uint16_t>(pointer, 64);
                        return span;
                    }
                }
            }

            [FieldOffset(256)] // size = 64
            public fixed byte _loop_filter_limits[64]; // unsigned char[64]

            public Span<byte> loop_filter_limits
            {
                get
                {
                    fixed (th_quant_info* @this = &this)
                    {
                        var pointer = &@this->_loop_filter_limits[0];
                        var span = new Span<byte>(pointer, 64);
                        return span;
                    }
                }
            }

            [FieldOffset(320)] // size = 144
            public fixed byte _qi_ranges[144]; // th_quant_ranges[2]

            public Span<th_quant_ranges> qi_ranges
            {
                get
                {
                    fixed (th_quant_info* @this = &this)
                    {
                        var pointer = &@this->_qi_ranges[0];
                        var span = new Span<th_quant_ranges>(pointer, 2);
                        return span;
                    }
                }
            }
        }

        // Struct @ codec.h:204:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 64, Pack = 4)]
        public struct th_info
        {
            [FieldOffset(0)] // size = 1
            public byte version_major;

            [FieldOffset(1)] // size = 1
            public byte version_minor;

            [FieldOffset(2)] // size = 1
            public byte version_subminor;

            [FieldOffset(4)] // size = 4
            public ogg_uint32_t frame_width;

            [FieldOffset(8)] // size = 4
            public ogg_uint32_t frame_height;

            [FieldOffset(12)] // size = 4
            public ogg_uint32_t pic_width;

            [FieldOffset(16)] // size = 4
            public ogg_uint32_t pic_height;

            [FieldOffset(20)] // size = 4
            public ogg_uint32_t pic_x;

            [FieldOffset(24)] // size = 4
            public ogg_uint32_t pic_y;

            [FieldOffset(28)] // size = 4
            public ogg_uint32_t fps_numerator;

            [FieldOffset(32)] // size = 4
            public ogg_uint32_t fps_denominator;

            [FieldOffset(36)] // size = 4
            public ogg_uint32_t aspect_numerator;

            [FieldOffset(40)] // size = 4
            public ogg_uint32_t aspect_denominator;

            [FieldOffset(44)] // size = 4
            public th_colorspace colorspace;

            [FieldOffset(48)] // size = 4
            public th_pixel_fmt pixel_fmt;

            [FieldOffset(52)] // size = 4
            public int target_bitrate;

            [FieldOffset(56)] // size = 4
            public int quality;

            [FieldOffset(60)] // size = 4
            public int keyframe_granule_shift;
        }

        // Struct @ ogg.h:27:9
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-pc-windows-msvc (lib\ogg\ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-pc-windows-msvc (lib\ogg\ogg.h)
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct ogg_iovec_t
        {
            [FieldOffset(0)] // size = 8
            public void* iov_base;

            [FieldOffset(8)] // size = 8
            public ulong iov_len;
        }

        // Struct @ codec.h:341:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct th_quant_ranges
        {
            [FieldOffset(0)] // size = 4
            public int nranges;

            [FieldOffset(8)] // size = 8
            public int* sizes;

            [FieldOffset(16)] // size = 8
            public th_quant_base* base_matrices;
        }

        // OpaqueType @ ogg.h:39:3
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-pc-windows-msvc (lib\ogg\ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-pc-windows-msvc (lib\ogg\ogg.h)
        [StructLayout(LayoutKind.Sequential)]
        public struct oggpack_buffer
        {
        }

        // OpaqueType @ ogg.h:85:3
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-pc-windows-msvc (lib\ogg\ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-pc-windows-msvc (lib\ogg\ogg.h)
        [StructLayout(LayoutKind.Sequential)]
        public struct ogg_stream_state
        {
        }

        // OpaqueType @ ogg.h:48:3
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-pc-windows-msvc (lib\ogg\ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-pc-windows-msvc (lib\ogg\ogg.h)
        [StructLayout(LayoutKind.Sequential)]
        public struct ogg_page
        {
        }

        // OpaqueType @ ogg.h:103:3
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-pc-windows-msvc (lib\ogg\ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-unknown-linux-gnu (lib/ogg/ogg.h)
        //	aarch64-pc-windows-msvc (lib\ogg\ogg.h)
        [StructLayout(LayoutKind.Sequential)]
        public struct ogg_packet
        {
        }

        // OpaqueType @ theorafile.h:93:3
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        [StructLayout(LayoutKind.Sequential)]
        public struct OggTheora_File
        {
        }

        // TypeAlias @ os_types.h:77:20
        //	aarch64-apple-darwin (lib/ogg/os_types.h)
        //	x86_64-pc-windows-msvc (lib\ogg\os_types.h)
        //	x86_64-apple-darwin (lib/ogg/os_types.h)
        //	x86_64-unknown-linux-gnu (lib/ogg/os_types.h)
        //	aarch64-unknown-linux-gnu (lib/ogg/os_types.h)
        //	aarch64-pc-windows-msvc (lib\ogg\os_types.h)
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct ogg_int64_t
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public long Data;

            public static implicit operator long(ogg_int64_t data) => data.Data;
            public static implicit operator ogg_int64_t(long data) => new() { Data = data };
        }

        // TypeAlias @ os_types.h:74:21
        //	aarch64-apple-darwin (lib/ogg/os_types.h)
        //	x86_64-pc-windows-msvc (lib\ogg\os_types.h)
        //	x86_64-apple-darwin (lib/ogg/os_types.h)
        //	x86_64-unknown-linux-gnu (lib/ogg/os_types.h)
        //	aarch64-unknown-linux-gnu (lib/ogg/os_types.h)
        //	aarch64-pc-windows-msvc (lib\ogg\os_types.h)
        [StructLayout(LayoutKind.Explicit, Size = 2, Pack = 2)]
        public struct ogg_uint16_t
        {
            [FieldOffset(0)] // size = 2, padding = 0
            public ushort Data;

            public static implicit operator ushort(ogg_uint16_t data) => data.Data;
            public static implicit operator ogg_uint16_t(ushort data) => new() { Data = data };
        }

        // TypeAlias @ theoradec.h:138:16
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-pc-windows-msvc (lib\theora\theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-pc-windows-msvc (lib\theora\theoradec.h)
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct th_stripe_decoded_func
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Th_ycbcr_buffer_Int_Int_Void Data;

            public static implicit operator FnPtr_VoidPtr_Th_ycbcr_buffer_Int_Int_Void(th_stripe_decoded_func data) => data.Data;
            public static implicit operator th_stripe_decoded_func(FnPtr_VoidPtr_Th_ycbcr_buffer_Int_Int_Void data) => new() { Data = data };
        }

        // TypeAlias @ codec.h:168:22
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 72, Pack = 8)]
        public struct th_ycbcr_buffer
        {
            [FieldOffset(0)] // size = 72, padding = 0
            public th_img_plane* Data;

            public static implicit operator th_img_plane*(th_ycbcr_buffer data) => data.Data;
            public static implicit operator th_ycbcr_buffer(th_img_plane* data) => new() { Data = data };
        }

        // TypeAlias @ os_types.h:76:21
        //	aarch64-apple-darwin (lib/ogg/os_types.h)
        //	x86_64-pc-windows-msvc (lib\ogg\os_types.h)
        //	x86_64-apple-darwin (lib/ogg/os_types.h)
        //	x86_64-unknown-linux-gnu (lib/ogg/os_types.h)
        //	aarch64-unknown-linux-gnu (lib/ogg/os_types.h)
        //	aarch64-pc-windows-msvc (lib\ogg\os_types.h)
        [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
        public struct ogg_uint32_t
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint Data;

            public static implicit operator uint(ogg_uint32_t data) => data.Data;
            public static implicit operator ogg_uint32_t(uint data) => new() { Data = data };
        }

        // TypeAlias @ codec.h:338:23
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 64, Pack = 8)]
        public struct th_quant_base
        {
            [FieldOffset(0)] // size = 64, padding = 0
            public byte* Data;

            public static implicit operator byte*(th_quant_base data) => data.Data;
            public static implicit operator th_quant_base(byte* data) => new() { Data = data };
        }

        // Enum @ codec.h:98:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public enum th_colorspace : int
        {
            TH_CS_UNSPECIFIED = 0,
            TH_CS_ITU_REC_470M = 1,
            TH_CS_ITU_REC_470BG = 2,
            TH_CS_NSPACES = 3
        }

        // Enum @ codec.h:114:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public enum th_pixel_fmt : int
        {
            TH_PF_420 = 0,
            TH_PF_RSVD = 1,
            TH_PF_422 = 2,
            TH_PF_444 = 3,
            TH_PF_NFORMATS = 4
        }

        // MacroObject @ codec.h:81:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public const int TH_ENOTFORMAT = -21;

        // MacroObject @ codec.h:235:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_ENOSEEK = -138;

        // MacroObject @ codec.h:83:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public const int TH_EVERSION = -22;

        // MacroObject @ theorafile.h:97:9
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        public const int TF_EUNSUPPORTED = -2;

        // MacroObject @ codec.h:75:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public const int TH_EFAULT = -1;

        // MacroObject @ theoradec.h:100:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-pc-windows-msvc (lib\theora\theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-pc-windows-msvc (lib\theora\theoradec.h)
        public const int TH_DECCTL_SET_TELEMETRY_QI = 13;

        // MacroObject @ codec.h:85:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public const int TH_EIMPL = -23;

        // MacroObject @ codec.h:425:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public const int TH_NDCT_TOKENS = 32;

        // MacroObject @ codec.h:223:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_HOLE = -3;

        // MacroObject @ codec.h:222:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_EOF = -2;

        // MacroObject @ codec.h:233:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_EBADPACKET = -136;

        // MacroObject @ codec.h:229:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_ENOTVORBIS = -132;

        // MacroObject @ theoradec.h:102:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-pc-windows-msvc (lib\theora\theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-pc-windows-msvc (lib\theora\theoradec.h)
        public const int TH_DECCTL_SET_TELEMETRY_BITS = 15;

        // MacroObject @ theoradec.h:79:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-pc-windows-msvc (lib\theora\theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-pc-windows-msvc (lib\theora\theoradec.h)
        public const int TH_DECCTL_SET_GRANPOS = 5;

        // MacroObject @ theoradec.h:93:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-pc-windows-msvc (lib\theora\theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-pc-windows-msvc (lib\theora\theoradec.h)
        public const int TH_DECCTL_SET_STRIPE_CB = 7;

        // MacroObject @ theoradec.h:98:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-pc-windows-msvc (lib\theora\theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-pc-windows-msvc (lib\theora\theoradec.h)
        public const int TH_DECCTL_SET_TELEMETRY_MV = 11;

        // MacroObject @ codec.h:225:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_EREAD = -128;

        // MacroObject @ codec.h:232:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_ENOTAUDIO = -135;

        // MacroObject @ codec.h:227:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_EIMPL = -130;

        // MacroObject @ codec.h:87:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public const int TH_EBADPACKET = -24;

        // MacroObject @ codec.h:231:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_EVERSION = -134;

        // MacroObject @ codec.h:91:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public const int TH_DUPFRAME = 1;

        // MacroObject @ theorafile.h:96:9
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        public const int TF_EUNKNOWN = -1;

        // MacroObject @ theoradec.h:96:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-pc-windows-msvc (lib\theora\theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-pc-windows-msvc (lib\theora\theoradec.h)
        public const int TH_DECCTL_SET_TELEMETRY_MBMODE = 9;

        // MacroObject @ codec.h:77:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public const int TH_EINVAL = -10;

        // MacroObject @ codec.h:423:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public const int TH_NHUFFMAN_TABLES = 80;

        // MacroObject @ codec.h:79:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-pc-windows-msvc (lib\theora\codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/codec.h)
        //	aarch64-pc-windows-msvc (lib\theora\codec.h)
        public const int TH_EBADHEADER = -20;

        // MacroObject @ codec.h:234:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_EBADLINK = -137;

        // MacroObject @ theoradec.h:50:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-pc-windows-msvc (lib\theora\theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-pc-windows-msvc (lib\theora\theoradec.h)
        public const int TH_DECCTL_GET_PPLEVEL_MAX = 1;

        // MacroObject @ codec.h:228:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_EINVAL = -131;

        // MacroObject @ theoradec.h:67:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-pc-windows-msvc (lib\theora\theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-unknown-linux-gnu (lib/theora/theoradec.h)
        //	aarch64-pc-windows-msvc (lib\theora\theoradec.h)
        public const int TH_DECCTL_SET_PPLEVEL = 3;

        // MacroObject @ codec.h:226:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_EFAULT = -129;

        // MacroObject @ codec.h:230:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_EBADHEADER = -133;

        // MacroObject @ codec.h:221:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-pc-windows-msvc (lib\vorbis\codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-unknown-linux-gnu (lib/vorbis/codec.h)
        //	aarch64-pc-windows-msvc (lib\vorbis\codec.h)
        public const int OV_FALSE = -1;

        // MacroObject @ theorafile.h:98:9
        //	aarch64-apple-darwin
        //	x86_64-pc-windows-msvc
        //	x86_64-apple-darwin
        //	x86_64-unknown-linux-gnu
        //	aarch64-unknown-linux-gnu
        //	aarch64-pc-windows-msvc
        public const int TF_ENODATASOURCE = -3;

        #endregion

        #region Setup & Teardown

        public static void Setup()
        {
            PreCompile();
        }

        private static void PreCompile()
        {
            var methods = typeof(Theorafile).GetMethods(
                System.Reflection.BindingFlags.DeclaredOnly |
                System.Reflection.BindingFlags.NonPublic |
                System.Reflection.BindingFlags.Public |
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.Static);

            foreach (var method in methods)
            {
                if (method.GetMethodBody() == null)
                {
                    RuntimeHelpers.PrepareMethod(method.MethodHandle);
                }
            }
        }

        public static void Teardown()
        {
        }

        #endregion

        #region Runtime

        public static class Runtime
        {

            /// <summary>
            ///     A boolean value type with the same memory layout as a <see cref="byte" /> in both managed and unmanaged contexts;
            ///     equivalent to a standard bool found in C/C++/ObjC where <c>0</c> is <c>false</c> and any other value is
            ///     <c>true</c>.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CBool : IEquatable<CBool>
            {
                private readonly byte _value;

                private CBool(bool value)
                {
                    _value = Convert.ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CBool" />.</returns>
                public static implicit operator CBool(bool value)
                {
                    return FromBoolean(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CBool" />.</returns>
                public static CBool FromBoolean(bool value)
                {
                    return new CBool(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="bool" />.</returns>
                public static implicit operator bool(CBool value)
                {
                    return ToBoolean(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="bool" />.</returns>
                public static bool ToBoolean(CBool value)
                {
                    return Convert.ToBoolean(value._value);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return ToBoolean(this).ToString();
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CBool b && Equals(b);
                }

                /// <inheritdoc />
                public bool Equals(CBool other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CBool left, CBool right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CBool left, CBool right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CBool left, CBool right)
                {
                    return left._value == right._value;
                }
            }

            /// <summary>
            ///     A value type with the same memory layout as a <see cref="byte" /> in a managed context and <c>char</c> in
            ///     an unmanaged context.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CChar : IEquatable<byte>, IEquatable<CChar>
            {
                private readonly byte _value;

                private CChar(byte value)
                {
                    _value = Convert.ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CChar" />.</returns>
                public static implicit operator CChar(byte value)
                {
                    return FromByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CChar" />.</returns>
                public static CChar FromByte(byte value)
                {
                    return new CChar(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="byte" />.</returns>
                public static implicit operator byte(CChar value)
                {
                    return ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="byte" />.</returns>
                public static byte ToByte(CChar value)
                {
                    return value._value;
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return _value.ToString(CultureInfo.InvariantCulture);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CChar value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(byte other)
                {
                    return _value == other;
                }

                /// <inheritdoc />
                public bool Equals(CChar other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CChar left, CChar right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CChar left, CChar right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CChar left, CChar right)
                {
                    return left._value == right._value;
                }
            }

#pragma warning disable CS1591

            /// <summary>
            ///     Utility methods for dealing with native C libraries.
            /// </summary>
            public static class CLibrary
            {
                /// <summary>
                ///     Loads a C shared library (`.dll`/`.dylib`/`.so`) into the application's memory space given the C
                ///     library's file name, partially qualified file path, or a fully qualified file path.
                /// </summary>
                /// <param name="name">The C library's file name, partially qualified file path, or a fully qualified file path.</param>
                /// <returns>A <see cref="IntPtr" /> handle if the C library was loaded; otherwise, a <see cref="IntPtr.Zero" /> handle.</returns>
                /// <remarks>
                ///     <para>
                ///         If the library was already loaded, calling <see cref="Load" /> returns the handle of the previous loaded
                ///         library and the reference count for the handle is incremented.
                ///     </para>
                ///     <para>You must call <see cref="Free" /> when finished using a handle of a dynamically loaded library.</para>
                /// </remarks>
                public static IntPtr Load(string name)
                {
                    if (IsLinux)
                    {
                        return libdl.dlopen(name, 0x101); // RTLD_GLOBAL | RTLD_LAZY
                    }

                    if (IsWindows)
                    {
                        return Kernel32.LoadLibrary(name);
                    }

                    if (IsDarwin)
                    {
                        return libSystem.dlopen(name, 0x101); // RTLD_GLOBAL | RTLD_LAZY
                    }

                    return IntPtr.Zero;
                }

                /// <summary>
                ///     Unloads a C shared library from the application's memory space given the library's handle.
                /// </summary>
                /// <param name="handle">The library's handle previously created by calling <see cref="Load" />.</param>
                /// <remarks>
                ///     <para>
                ///         If the library was loaded multiple times, the reference count for the handle is decremented upon calling
                ///         <see cref="Free" /> and the library is not yet unloaded from memory.
                ///     </para>
                /// </remarks>
                public static void Free(IntPtr handle)
                {
                    if (IsLinux)
                    {
                        libdl.dlclose(handle);
                    }

                    if (IsWindows)
                    {
                        Kernel32.FreeLibrary(handle);
                    }

                    if (IsDarwin)
                    {
                        libSystem.dlclose(handle);
                    }
                }

                public static IntPtr GetExport(IntPtr handle, string symbolName)
                {
                    if (IsLinux)
                    {
                        return libdl.dlsym(handle, symbolName);
                    }

                    if (IsWindows)
                    {
                        return Kernel32.GetProcAddress(handle, symbolName);
                    }

                    if (IsDarwin)
                    {
                        return libSystem.dlsym(handle, symbolName);
                    }

                    return IntPtr.Zero;
                }

                private static bool IsWindows
                {
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    get =>
#if NET5_0_OR_GREATER
            OperatingSystem.IsWindows();
#elif NETFRAMEWORK || NETSTANDARD || NETCOREAPP
            RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
#else
            false;
#endif
                }

                private static bool IsDarwin
                {
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    get =>
#if NET5_0_OR_GREATER
            OperatingSystem.IsMacOS() || 
            OperatingSystem.IsMacCatalyst() ||
            OperatingSystem.IsIOS() || 
            OperatingSystem.IsTvOS() ||
            OperatingSystem.IsWatchOS();
#elif NETFRAMEWORK || NETSTANDARD || NETCOREAPP
            RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
#else
            false;
#endif
                }

                private static bool IsLinux
                {
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    get =>
#if NET5_0_OR_GREATER
            OperatingSystem.IsLinux() ||
            OperatingSystem.IsFreeBSD() ||
            OperatingSystem.IsAndroid();
#elif NETFRAMEWORK || NETSTANDARD || NETCOREAPP
            RuntimeInformation.IsOSPlatform(OSPlatform.Linux);
#else
            false;
#endif
                }

                [System.Security.SuppressUnmanagedCodeSecurity]
                private static class libdl
                {
                    private const string LibraryName = "libdl";

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
                    public static extern IntPtr dlopen(string fileName, int flags);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
                    public static extern IntPtr dlsym(IntPtr handle, string name);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall)]
                    public static extern int dlclose(IntPtr handle);
                }

                [System.Security.SuppressUnmanagedCodeSecurity]
                private static class libSystem
                {
                    private const string LibraryName = "libSystem";

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
                    public static extern IntPtr dlopen(string fileName, int flags);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
                    public static extern IntPtr dlsym(IntPtr handle, string name);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall)]
                    public static extern int dlclose(IntPtr handle);
                }

                [System.Security.SuppressUnmanagedCodeSecurity]
                private static class Kernel32
                {
                    private const string LibraryName = "kernel32";

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi,
                        ExactSpelling = true, SetLastError = true)]
                    public static extern IntPtr LoadLibrary(string fileName);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi,
                        ExactSpelling = true, SetLastError = true)]
                    public static extern IntPtr GetProcAddress(IntPtr module, string procName);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, SetLastError = true)]
                    public static extern int FreeLibrary(IntPtr module);
                }
            }

            /// <summary>
            ///     A pointer value type of bytes that represent a string; the C type `char*`.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly unsafe struct CString : IEquatable<CString>
            {
                internal readonly nint _pointer;

                /// <summary>
                ///     Gets a value indicating whether this <see cref="CString" /> is a null pointer.
                /// </summary>
                public bool IsNull => _pointer == 0;

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CString(byte* value)
                {
                    _pointer = (nint)value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CString(nint value)
                {
                    _pointer = value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="s">The string value.</param>
                public CString(string s)
                {
                    _pointer = CStrings.CString(s);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static explicit operator CString(nint value)
                {
                    return FromIntPtr(value);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString FromIntPtr(nint value)
                {
                    return new CString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static implicit operator CString(byte* value)
                {
                    return From(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString From(byte* value)
                {
                    return new CString((nint)value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static implicit operator nint(CString value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static nint ToIntPtr(CString value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CString" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static implicit operator string(CString value)
                {
                    return ToString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CString" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static string ToString(CString value)
                {
                    return CStrings.String(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static implicit operator CString(string s)
                {
                    return FromString(s);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString FromString(string s)
                {
                    return CStrings.CString(s);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return CStrings.String(this);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CString value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CString other)
                {
                    return _pointer == other._pointer;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _pointer.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CString left, CString right)
                {
                    return left._pointer == right._pointer;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CString left, CString right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CString left, CString right)
                {
                    return left._pointer == right._pointer;
                }
            }

            /// <summary>
            ///     Utility methods for interoperability with C style strings in C#.
            /// </summary>
            public static unsafe class CStrings
            {
                private static readonly Dictionary<uint, CString> StringHashesToPointers = new();
                private static readonly Dictionary<nint, string> PointersToStrings = new();
                private static readonly Dictionary<uint, CStringWide> StringHashesToPointersWide = new();
                private static readonly Dictionary<nint, string> PointersToStringsWide = new();

                /// <summary>
                ///     Converts a C style string (ANSI or UTF-8) of type `char` (one dimensional byte array
                ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="value">A pointer to the C string.</param>
                /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
                public static string String(CString value)
                {
                    if (value.IsNull)
                    {
                        return string.Empty;
                    }

                    if (PointersToStrings.TryGetValue(value._pointer, out var result))
                    {
                        return result;
                    }

                    var hash = Djb2((byte*)value._pointer);
                    if (StringHashesToPointers.TryGetValue(hash, out var pointer2))
                    {
                        result = PointersToStrings[pointer2._pointer];
                        return result;
                    }

                    // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                    // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                    result = Marshal.PtrToStringAnsi(value._pointer);

                    if (string.IsNullOrEmpty(result))
                    {
                        return string.Empty;
                    }

                    StringHashesToPointers.Add(hash, value);
                    PointersToStrings.Add(value._pointer, result);

                    return result;
                }

                /// <summary>
                ///     Converts a C style string (unicode) of type `wchar_t` (one dimensional ushort array
                ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="value">A pointer to the C string.</param>
                /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
                public static string StringWide(CStringWide value)
                {
                    if (value.IsNull)
                    {
                        return string.Empty;
                    }

                    if (PointersToStringsWide.TryGetValue(value._pointer, out var result))
                    {
                        return result;
                    }

                    var hash = Djb2((byte*)value._pointer);
                    if (StringHashesToPointersWide.TryGetValue(hash, out var pointer2))
                    {
                        result = PointersToStringsWide[pointer2._pointer];
                        return result;
                    }

                    // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                    // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                    result = Marshal.PtrToStringUni(pointer2._pointer);

                    if (string.IsNullOrEmpty(result))
                    {
                        return string.Empty;
                    }

                    StringHashesToPointersWide.Add(hash, value);
                    PointersToStringsWide.Add(value._pointer, result);

                    return result;
                }

                /// <summary>
                ///     Converts a UTF-16 <see cref="string" /> to a C style string (one dimensional byte array terminated by a
                ///     <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <param name="str">The <see cref="string" />.</param>
                /// <returns>A C string pointer.</returns>
                public static CString CString(string str)
                {
                    var hash = Djb2(str);
                    if (StringHashesToPointers.TryGetValue(hash, out var r))
                    {
                        return r;
                    }

                    // ReSharper disable once JoinDeclarationAndInitializer
                    var pointer = Marshal.StringToHGlobalAnsi(str);
                    StringHashesToPointers.Add(hash, new CString(pointer));
                    PointersToStrings.Add(pointer, str);

                    return new CString(pointer);
                }

                /// <summary>
                ///     Converts a C string pointer (one dimensional byte array terminated by a
                ///     <c>0x0</c>) for a specified <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="str">The <see cref="string" />.</param>
                /// <returns>A C string pointer.</returns>
                public static CStringWide CStringWide(string str)
                {
                    var hash = Djb2(str);
                    if (StringHashesToPointersWide.TryGetValue(hash, out var r))
                    {
                        return r;
                    }

                    // ReSharper disable once JoinDeclarationAndInitializer
                    var pointer = Marshal.StringToHGlobalUni(str);
                    StringHashesToPointersWide.Add(hash, new CStringWide(pointer));
                    PointersToStringsWide.Add(pointer, str);

                    return new CStringWide(pointer);
                }

                /// <summary>
                ///     Converts an array of strings to an array of C strings of type `char` (multi-dimensional array of one
                ///     dimensional byte arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <remarks>
                ///     <para>Calls <see cref="CString" />.</para>
                /// </remarks>
                /// <param name="values">The strings.</param>
                /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
                public static CString* CStringArray(ReadOnlySpan<string> values)
                {
                    var pointerSize = IntPtr.Size;
                    var result = (CString*)Marshal.AllocHGlobal(pointerSize * values.Length);
                    for (var i = 0; i < values.Length; ++i)
                    {
                        var @string = values[i];
                        var cString = CString(@string);
                        result[i] = cString;
                    }

                    return result;
                }

                /// <summary>
                ///     Converts an array of strings to an array of C strings of type `wchar_t` (multi-dimensional array of one
                ///     dimensional ushort arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <remarks>
                ///     <para>Calls <see cref="CString" />.</para>
                /// </remarks>
                /// <param name="values">The strings.</param>
                /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
                public static CStringWide* CStringWideArray(ReadOnlySpan<string> values)
                {
                    var pointerSize = IntPtr.Size;
                    var result = (CStringWide*)Marshal.AllocHGlobal(pointerSize * values.Length);
                    for (var i = 0; i < values.Length; ++i)
                    {
                        var @string = values[i];
                        var cString = CStringWide(@string);
                        result[i] = cString;
                    }

                    return result;
                }

                /// <summary>
                ///     Frees the memory for all previously allocated C strings and releases references to all <see cref="string" />
                ///     objects which happened during <see cref="String" />, <see cref="StringWide" />, <see cref="CString" />
                ///     or <see cref="CStringWide" />. Does <b>not</b> garbage collect.
                /// </summary>
                public static void FreeAllStrings()
                {
                    foreach (var (ptr, _) in PointersToStrings)
                    {
                        Marshal.FreeHGlobal(ptr);
                    }

                    // We can not guarantee that the application has not a strong reference the string since it was allocated,
                    //  so we have to let the GC take the wheel here. Thus, this method should NOT garbage collect; that's
                    //  on the responsibility of the application developer. The best we can do is just remove any and all strong
                    //  references we have here to the strings.

                    StringHashesToPointers.Clear();
                    PointersToStrings.Clear();
                }

                /// <summary>
                ///     Frees the memory for specific previously allocated C strings and releases associated references to
                ///     <see cref="string" /> objects which happened during <see cref="String" /> or
                ///     <see cref="CString" />. Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="pointers">The C string pointers.</param>
                /// <param name="count">The number of C string pointers.</param>
                public static void FreeCStrings(CString* pointers, int count)
                {
                    for (var i = 0; i < count; i++)
                    {
                        var ptr = pointers[i];
                        FreeCString(ptr);
                    }

                    Marshal.FreeHGlobal((IntPtr)pointers);
                }

                /// <summary>
                ///     Frees the memory for the previously allocated C string and releases reference to the
                ///     <see cref="string" /> object which happened during <see cref="String" /> or <see cref="CString" />.
                ///     Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="value">The string.</param>
                public static void FreeCString(CString value)
                {
                    if (!PointersToStrings.ContainsKey(value._pointer))
                    {
                        return;
                    }

                    Marshal.FreeHGlobal(value);
                    var hash = Djb2(value);
                    StringHashesToPointers.Remove(hash);
                    PointersToStrings.Remove(value._pointer);
                }

                /// <summary>
                ///     Frees the memory for the previously allocated C string and releases reference to the
                ///     <see cref="string" /> object which happened during <see cref="StringWide" /> or <see cref="CStringWide" />.
                ///     Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="value">The string.</param>
                public static void FreeCStringWide(CStringWide value)
                {
                    if (!PointersToStringsWide.ContainsKey(value._pointer))
                    {
                        return;
                    }

                    Marshal.FreeHGlobal(value);
                    var hash = Djb2(value);
                    StringHashesToPointersWide.Remove(hash);
                    PointersToStringsWide.Remove(value._pointer);
                }

                // djb2 is named after https://en.wikipedia.org/wiki/Daniel_J._Bernstein
                //  References:
                //  (1) https://stackoverflow.com/a/7666577/2171957
                //  (2) http://www.cse.yorku.ca/~oz/hash.html
                //  (3) https://groups.google.com/g/comp.lang.c/c/lSKWXiuNOAk/m/zstZ3SRhCjgJ
                private static uint Djb2(byte* str)
                {
                    uint hash = 5381;

                    unchecked
                    {
                        uint c;
                        while ((c = *str++) != 0)
                        {
                            hash = (hash << 5) + hash + c; // hash * 33 + c
                        }
                    }

                    return hash;
                }

                private static uint Djb2(string str)
                {
                    uint hash = 5381;

                    // ReSharper disable once ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
                    foreach (var c in str)
                    {
                        hash = (hash << 5) + hash + c; // hash * 33 + c
                    }

                    return hash;
                }
            }

            /// <summary>
            ///     A pointer value type that represents a wide string; C type `wchar_t*`.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly unsafe struct CStringWide : IEquatable<CStringWide>
            {
                internal readonly nint _pointer;

                /// <summary>
                ///     Gets a value indicating whether this <see cref="CStringWide" /> is a null pointer.
                /// </summary>
                public bool IsNull => _pointer == 0;

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CStringWide(byte* value)
                {
                    _pointer = (nint)value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CStringWide(nint value)
                {
                    _pointer = value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="s">The string value.</param>
                public CStringWide(string s)
                {
                    _pointer = CStrings.CStringWide(s);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static explicit operator CStringWide(nint value)
                {
                    return FromIntPtr(value);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide FromIntPtr(nint value)
                {
                    return new CStringWide(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static implicit operator CStringWide(byte* value)
                {
                    return From(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide From(byte* value)
                {
                    return new CStringWide((nint)value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static implicit operator nint(CStringWide value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static nint ToIntPtr(CStringWide value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CStringWide" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static implicit operator string(CStringWide value)
                {
                    return ToString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CStringWide" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static string ToString(CStringWide value)
                {
                    return CStrings.StringWide(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static implicit operator CStringWide(string s)
                {
                    return FromString(s);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide FromString(string s)
                {
                    return CStrings.CStringWide(s);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return CStrings.StringWide(this);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CStringWide value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CStringWide other)
                {
                    return _pointer == other._pointer;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _pointer.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CStringWide left, CStringWide right)
                {
                    return left._pointer == right._pointer;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CStringWide left, CStringWide right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CStringWide left, CStringWide right)
                {
                    return left._pointer == right._pointer;
                }
            }
        }

        #endregion
    }
}