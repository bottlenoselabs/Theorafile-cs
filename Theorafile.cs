// <auto-generated>
//  This code was generated by the following tool on 2022-07-31 09:31:48 GMT-04:00:
//      https://github.com/bottlenoselabs/c2cs (v3.2.8.0)
//      
//  Changes to this file may cause incorrect behavior and will be lost if the code is
//      regenerated. To extend or add functionality use a partial class in a new file.
// </auto-generated>
// ReSharper disable All

#nullable enable
#pragma warning disable 1591
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using static bottlenoselabs.Theorafile.Runtime;

namespace bottlenoselabs
{
    public static unsafe partial class Theorafile
    {
        private const string LibraryName = "Theorafile";

        #region API

        // Function @ codec.h:216:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis_halfrate(vorbis_info* v, int flag);

        // Function @ ogg.h:189:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_check(ogg_stream_state* os);

        // Function @ theoradec.h:262:13
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void th_setup_free(th_setup_info* _setup);

        // Function @ ogg.h:132:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpack_read1(oggpack_buffer* b);

        // Function @ ogg.h:133:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpack_bytes(oggpack_buffer* b);

        // Function @ ogg.h:144:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpackB_readinit(oggpack_buffer* b, byte* buf, int bytes);

        // Function @ theorafile.h:137:14
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_readvideo(OggTheora_File* file, CString buffer, int numframes);

        // Function @ ogg.h:124:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpack_writeclear(oggpack_buffer* b);

        // Function @ ogg.h:123:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpack_reset(oggpack_buffer* b);

        // Function @ codec.h:203:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis_headerin(vorbis_info* vi, vorbis_comment* vc, ogg_packet* op);

        // Function @ ogg.h:122:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpack_writecopy(oggpack_buffer* b, void* source, long bits);

        // Function @ codec.h:567:14
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CString th_comment_query(th_comment* _tc, CString _tag, int _count);

        // Function @ ogg.h:197:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_page_eos(ogg_page* og);

        // Function @ ogg.h:198:21
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ogg_int64_t ogg_page_granulepos(ogg_page* og);

        // Function @ codec.h:198:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_bitrate_flushpacket(vorbis_dsp_state* vd, ogg_packet* op);

        // Function @ codec.h:181:20
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CString vorbis_version_string();

        // Function @ theorafile.h:138:14
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_readaudio(OggTheora_File* file, float* buffer, int samples);

        // Function @ ogg.h:143:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpackB_writeclear(oggpack_buffer* b);

        // Function @ ogg.h:148:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpackB_adv(oggpack_buffer* b, int bits);

        // Function @ ogg.h:178:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_pagein(ogg_stream_state* os, ogg_page* og);

        // Function @ theorafile.h:120:15
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void tf_audioinfo(OggTheora_File* file, int* channels, int* samplerate);

        // Function @ ogg.h:151:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpackB_read1(oggpack_buffer* b);

        // Function @ codec.h:177:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void vorbis_dsp_clear(vorbis_dsp_state* v);

        // Function @ codec.h:192:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern double** vorbis_analysis_buffer(vorbis_dsp_state* v, int vals);

        // Function @ ogg.h:171:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_sync_destroy(ogg_sync_state* oy);

        // Function @ ogg.h:142:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpackB_reset(oggpack_buffer* b);

        // Function @ codec.h:167:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void vorbis_comment_init(vorbis_comment* vc);

        // Function @ ogg.h:169:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_sync_clear(ogg_sync_state* oy);

        // Function @ ogg.h:149:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpackB_adv1(oggpack_buffer* b);

        // Function @ ogg.h:139:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpackB_writetrunc(oggpack_buffer* b, long bits);

        // Function @ ogg.h:146:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpackB_look(oggpack_buffer* b, int bits);

        // Function @ codec.h:209:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis_trackonly(vorbis_block* vb, ogg_packet* op);

        // Function @ ogg.h:140:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpackB_writealign(oggpack_buffer* b);

        // Function @ theorafile.h:113:15
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void tf_videoinfo(OggTheora_File* file, int* width, int* height, double* fps, th_pixel_fmt* fmt);

        // Function @ theoradec.h:231:12
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int th_decode_headerin(th_info* _info, th_comment* _tc, th_setup_info** _setup, ogg_packet* _op);

        // Function @ codec.h:210:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis_blockin(vorbis_dsp_state* v, vorbis_block* vb);

        // Function @ codec.h:530:13
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void th_comment_init(th_comment* _tc);

        // Function @ codec.h:488:15
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern double th_granule_time(void* _encdec, ogg_int64_t _granpos);

        // Function @ ogg.h:161:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_pageout(ogg_stream_state* os, ogg_page* og);

        // Function @ ogg.h:194:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_page_version(ogg_page* og);

        // Function @ ogg.h:203:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void ogg_packet_clear(ogg_packet* op);

        // Function @ ogg.h:168:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_sync_init(ogg_sync_state* oy);

        // Function @ ogg.h:125:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpack_readinit(oggpack_buffer* b, byte* buf, int bytes);

        // Function @ codec.h:211:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis_pcmout(vorbis_dsp_state* v, double*** pcm);

        // Function @ codec.h:208:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis(vorbis_block* vb, ogg_packet* op);

        // Function @ codec.h:213:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis_read(vorbis_dsp_state* v, int samples);

        // Function @ ogg.h:159:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_iovecin(ogg_stream_state* os, ogg_iovec_t* iov, int count, long e_o_s, ogg_int64_t granulepos);

        // Function @ codec.h:551:13
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void th_comment_add_tag(th_comment* _tc, CString _tag, CString _val);

        // Function @ codec.h:195:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_analysis(vorbis_block* vb, ogg_packet* op);

        // Function @ codec.h:519:13
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void th_info_init(th_info* _info);

        // Function @ ogg.h:158:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_packetin(ogg_stream_state* os, ogg_packet* op);

        // Function @ ogg.h:154:23
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* oggpackB_get_buffer(oggpack_buffer* b);

        // Function @ codec.h:197:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_bitrate_addblock(vorbis_block* vb);

        // Function @ theorafile.h:99:14
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_open_callbacks(void* datasource, OggTheora_File* file, tf_callbacks io);

        // Function @ ogg.h:129:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpack_adv(oggpack_buffer* b, int bits);

        // Function @ codec.h:581:13
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void th_comment_clear(th_comment* _tc);

        // Function @ ogg.h:185:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_clear(ogg_stream_state* os);

        // Function @ ogg.h:127:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpack_look(oggpack_buffer* b, int bits);

        // Function @ codec.h:166:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_info_blocksize(vorbis_info* vi, int zo);

        // Function @ ogg.h:187:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_reset_serialno(ogg_stream_state* os, int serialno);

        // Function @ ogg.h:118:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpack_writeinit(oggpack_buffer* b);

        // Function @ ogg.h:121:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpack_writealign(oggpack_buffer* b);

        // Function @ ogg.h:163:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_flush(ogg_stream_state* os, ogg_page* og);

        // Function @ ogg.h:150:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpackB_read(oggpack_buffer* b, int bits);

        // Function @ ogg.h:175:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_sync_wrote(ogg_sync_state* oy, long bytes);

        // Function @ ogg.h:162:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_pageout_fill(ogg_stream_state* os, ogg_page* og, int nfill);

        // Function @ codec.h:524:13
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void th_info_clear(th_info* _info);

        // Function @ codec.h:466:21
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ogg_uint32_t th_version_number();

        // Function @ ogg.h:196:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_page_bos(ogg_page* og);

        // Function @ codec.h:175:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_block_init(vorbis_dsp_state* v, vorbis_block* vb);

        // Function @ codec.h:456:20
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CString th_version_string();

        // Function @ ogg.h:138:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int oggpackB_writecheck(oggpack_buffer* b);

        // Function @ ogg.h:186:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_reset(ogg_stream_state* os);

        // Function @ theorafile.h:108:15
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void tf_close(OggTheora_File* file);

        // Function @ ogg.h:135:23
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* oggpack_get_buffer(oggpack_buffer* b);

        // Function @ ogg.h:147:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpackB_look1(oggpack_buffer* b);

        // Function @ ogg.h:176:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long ogg_sync_pageseek(ogg_sync_state* oy, ogg_page* og);

        // Function @ ogg.h:174:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CString ogg_sync_buffer(ogg_sync_state* oy, long size);

        // Function @ ogg.h:130:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpack_adv1(oggpack_buffer* b);

        // Function @ codec.h:172:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_comment_query_count(vorbis_comment* vc, CString tag);

        // Function @ codec.h:178:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern double vorbis_granule_time(vorbis_dsp_state* v, ogg_int64_t granulepos);

        // Function @ ogg.h:164:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_flush_fill(ogg_stream_state* os, ogg_page* og, int nfill);

        // Function @ codec.h:187:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_analysis_headerout(vorbis_dsp_state* v, vorbis_comment* vc, ogg_packet* op, ogg_packet* op_comm, ogg_packet* op_code);

        // Function @ theoradec.h:294:12
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int th_decode_packetin(th_dec_ctx* _dec, ogg_packet* _op, ogg_int64_t* _granpos);

        // Function @ ogg.h:177:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_sync_pageout(ogg_sync_state* oy, ogg_page* og);

        // Function @ ogg.h:152:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpackB_bytes(oggpack_buffer* b);

        // Function @ ogg.h:184:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_init(ogg_stream_state* os, int serialno);

        // Function @ ogg.h:137:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpackB_writeinit(oggpack_buffer* b);

        // Function @ codec.h:169:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void vorbis_comment_add_tag(vorbis_comment* vc, CString tag, CString contents);

        // Function @ theorafile.h:112:14
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_hasaudio(OggTheora_File* file);

        // Function @ theorafile.h:104:14
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_fopen(CString fname, OggTheora_File* file);

        // Function @ theorafile.h:128:15
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void tf_reset(OggTheora_File* file);

        // Function @ codec.h:206:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis_init(vorbis_dsp_state* v, vorbis_info* vi);

        // Function @ codec.h:173:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void vorbis_comment_clear(vorbis_comment* vc);

        // Function @ codec.h:509:12
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int th_packet_iskeyframe(ogg_packet* _op);

        // Function @ ogg.h:180:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_packetpeek(ogg_stream_state* os, ogg_packet* op);

        // Function @ codec.h:165:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void vorbis_info_clear(vorbis_info* vi);

        // Function @ ogg.h:200:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long ogg_page_pageno(ogg_page* og);

        // Function @ ogg.h:126:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpack_write(oggpack_buffer* b, ulong value, int bits);

        // Function @ codec.h:193:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_analysis_wrote(vorbis_dsp_state* v, int vals);

        // Function @ ogg.h:128:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpack_look1(oggpack_buffer* b);

        // Function @ codec.h:498:12
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int th_packet_isheader(ogg_packet* _op);

        // Function @ ogg.h:141:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpackB_writecopy(oggpack_buffer* b, void* source, long bits);

        // Function @ ogg.h:145:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpackB_write(oggpack_buffer* b, ulong value, int bits);

        // Function @ codec.h:176:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_block_clear(vorbis_block* vb);

        // Function @ ogg.h:134:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpack_bits(oggpack_buffer* b);

        // Function @ codec.h:575:12
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int th_comment_query_count(th_comment* _tc, CString _tag);

        // Function @ ogg.h:153:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpackB_bits(oggpack_buffer* b);

        // Function @ codec.h:164:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void vorbis_info_init(vorbis_info* vi);

        // Function @ ogg.h:190:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_eos(ogg_stream_state* os);

        // Function @ ogg.h:170:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_sync_reset(ogg_sync_state* oy);

        // Function @ theorafile.h:150:14
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_setaudiotrack(OggTheora_File* file, int vtrack);

        // Function @ ogg.h:131:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long oggpack_read(oggpack_buffer* b, int bits);

        // Function @ theoradec.h:311:12
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int th_decode_ycbcr_out(th_dec_ctx* _dec, th_ycbcr_buffer _ycbcr);

        // Function @ codec.h:171:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CString vorbis_comment_query(vorbis_comment* vc, CString tag, int count);

        // Function @ codec.h:217:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis_halfrate_p(vorbis_info* v);

        // Function @ theorafile.h:162:14
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_setvideotrack(OggTheora_File* file, int ttrack);

        // Function @ codec.h:207:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis_restart(vorbis_dsp_state* v);

        // Function @ codec.h:540:13
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void th_comment_add(th_comment* _tc, CString _comment);

        // Function @ ogg.h:179:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_packetout(ogg_stream_state* os, ogg_packet* op);

        // Function @ ogg.h:195:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_page_continued(ogg_page* og);

        // Function @ theoradec.h:315:13
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void th_decode_free(th_dec_ctx* _dec);

        // Function @ codec.h:202:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis_idheader(ogg_packet* op);

        // Function @ ogg.h:120:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void oggpack_writetrunc(oggpack_buffer* b, long bits);

        // Function @ codec.h:476:20
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ogg_int64_t th_granule_frame(void* _encdec, ogg_int64_t _granpos);

        // Function @ codec.h:186:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_commentheader_out(vorbis_comment* vc, ogg_packet* op);

        // Function @ codec.h:168:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void vorbis_comment_add(vorbis_comment* vc, CString comment);

        // Function @ ogg.h:119:14
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int oggpack_writecheck(oggpack_buffer* b);

        // Function @ ogg.h:201:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_page_packets(ogg_page* og);

        // Function @ ogg.h:188:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_stream_destroy(ogg_stream_state* os);

        // Function @ ogg.h:172:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_sync_check(ogg_sync_state* oy);

        // Function @ codec.h:194:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_analysis_blockout(vorbis_dsp_state* v, vorbis_block* vb);

        // Function @ ogg.h:199:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int ogg_page_serialno(ogg_page* og);

        // Function @ codec.h:214:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern long vorbis_packet_blocksize(vorbis_info* vi, ogg_packet* op);

        // Function @ theoradec.h:255:20
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern th_dec_ctx* th_decode_alloc(th_info* _info, th_setup_info* _setup);

        // Function @ codec.h:212:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_synthesis_lapout(vorbis_dsp_state* v, double*** pcm);

        // Function @ ogg.h:192:17
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void ogg_page_checksum_set(ogg_page* og);

        // Function @ codec.h:185:17
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int vorbis_analysis_init(vorbis_dsp_state* v, vorbis_info* vi);

        // Function @ theorafile.h:127:14
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_eos(OggTheora_File* file);

        // Function @ theoradec.h:271:12
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int th_decode_ctl(th_dec_ctx* _dec, int _req, void* _buf, ulong _buf_sz);

        // Function @ theorafile.h:111:14
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int tf_hasvideo(OggTheora_File* file);

        #endregion

        #region Types

        // FunctionPointer @ NoLocation
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr_Ogg_int64_t_Int_Int
        {
            public delegate* unmanaged<void*, ogg_int64_t, int, int> Pointer;
        }

        // FunctionPointer @ NoLocation
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr_Th_ycbcr_buffer_Int_Int_Void
        {
            public delegate* unmanaged<void*, th_ycbcr_buffer, int, int, void> Pointer;
        }

        // FunctionPointer @ NoLocation
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr_Ulong_Ulong_VoidPtr_Ulong
        {
            public delegate* unmanaged<void*, ulong, ulong, void*, ulong> Pointer;
        }

        // FunctionPointer @ NoLocation
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr_Int
        {
            public delegate* unmanaged<void*, int> Pointer;
        }

        // Struct @ codec.h:142:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct th_img_plane
        {
            [FieldOffset(0)] // size = 4
            public int width;

            [FieldOffset(4)] // size = 4
            public int height;

            [FieldOffset(8)] // size = 4
            public int stride;

            [FieldOffset(16)] // size = 8
            public byte* data;
        }

        // Struct @ ogg.h:43:9
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct ogg_page
        {
            [FieldOffset(0)] // size = 8
            public byte* header;

            [FieldOffset(8)] // size = 8
            public long header_len;

            [FieldOffset(16)] // size = 8
            public byte* body;

            [FieldOffset(24)] // size = 8
            public long body_len;
        }

        // Struct @ codec.h:341:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct th_quant_ranges
        {
            [FieldOffset(0)] // size = 4
            public int nranges;

            [FieldOffset(8)] // size = 8
            public int* sizes;

            [FieldOffset(16)] // size = 8
            public th_quant_base* base_matrices;
        }

        // Struct @ codec.h:27:16
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
        public struct vorbis_info
        {
            [FieldOffset(0)] // size = 4
            public int version;

            [FieldOffset(4)] // size = 4
            public int channels;

            [FieldOffset(8)] // size = 8
            public long rate;

            [FieldOffset(16)] // size = 8
            public long bitrate_upper;

            [FieldOffset(24)] // size = 8
            public long bitrate_nominal;

            [FieldOffset(32)] // size = 8
            public long bitrate_lower;

            [FieldOffset(40)] // size = 8
            public long bitrate_window;

            [FieldOffset(48)] // size = 8
            public void* codec_setup;
        }

        // Struct @ theorafile.h:56:16
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [StructLayout(LayoutKind.Explicit, Size = 536, Pack = 8)]
        public struct OggTheora_File
        {
            [FieldOffset(0)] // size = 32
            public ogg_sync_state sync;

            [FieldOffset(32)] // size = 32
            public ogg_page page;

            [FieldOffset(64)] // size = 4
            public int eos;

            [FieldOffset(68)] // size = 4
            public int tpackets;

            [FieldOffset(72)] // size = 4
            public int vpackets;

            [FieldOffset(80)] // size = 8
            public ogg_stream_state* tstream;

            [FieldOffset(88)] // size = 8
            public ogg_stream_state* vstream;

            [FieldOffset(96)] // size = 8
            public th_info* tinfo;

            [FieldOffset(104)] // size = 8
            public vorbis_info* vinfo;

            [FieldOffset(112)] // size = 8
            public th_comment* tcomment;

            [FieldOffset(120)] // size = 8
            public vorbis_comment* vcomment;

            [FieldOffset(128)] // size = 4
            public int vtracks;

            [FieldOffset(132)] // size = 4
            public int vtrack;

            [FieldOffset(136)] // size = 4
            public int ttracks;

            [FieldOffset(140)] // size = 4
            public int ttrack;

            [FieldOffset(144)] // size = 8
            public th_dec_ctx** tdec;

            [FieldOffset(152)] // size = 4
            public int vdsp_init;

            [FieldOffset(160)] // size = 144
            public vorbis_dsp_state vdsp;

            [FieldOffset(304)] // size = 4
            public int vblock_init;

            [FieldOffset(312)] // size = 192
            public vorbis_block vblock;

            [FieldOffset(504)] // size = 24
            public tf_callbacks io;

            [FieldOffset(528)] // size = 8
            public void* datasource;
        }

        // Struct @ codec.h:58:16
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 144, Pack = 8)]
        public struct vorbis_dsp_state
        {
            [FieldOffset(0)] // size = 4
            public int analysisp;

            [FieldOffset(8)] // size = 8
            public vorbis_info* vi;

            [FieldOffset(16)] // size = 8
            public double** pcm;

            [FieldOffset(24)] // size = 8
            public double** pcmret;

            [FieldOffset(32)] // size = 4
            public int pcm_storage;

            [FieldOffset(36)] // size = 4
            public int pcm_current;

            [FieldOffset(40)] // size = 4
            public int pcm_returned;

            [FieldOffset(44)] // size = 4
            public int preextrapolate;

            [FieldOffset(48)] // size = 4
            public int eofflag;

            [FieldOffset(56)] // size = 8
            public long lW;

            [FieldOffset(64)] // size = 8
            public long W;

            [FieldOffset(72)] // size = 8
            public long nW;

            [FieldOffset(80)] // size = 8
            public long centerW;

            [FieldOffset(88)] // size = 8
            public ogg_int64_t granulepos;

            [FieldOffset(96)] // size = 8
            public ogg_int64_t sequence;

            [FieldOffset(104)] // size = 8
            public ogg_int64_t glue_bits;

            [FieldOffset(112)] // size = 8
            public ogg_int64_t time_bits;

            [FieldOffset(120)] // size = 8
            public ogg_int64_t floor_bits;

            [FieldOffset(128)] // size = 8
            public ogg_int64_t res_bits;

            [FieldOffset(136)] // size = 8
            public void* backend_state;
        }

        // Struct @ ogg.h:105:9
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct ogg_sync_state
        {
            [FieldOffset(0)] // size = 8
            public byte* data;

            [FieldOffset(8)] // size = 4
            public int storage;

            [FieldOffset(12)] // size = 4
            public int fill;

            [FieldOffset(16)] // size = 4
            public int returned;

            [FieldOffset(20)] // size = 4
            public int unsynced;

            [FieldOffset(24)] // size = 4
            public int headerbytes;

            [FieldOffset(28)] // size = 4
            public int bodybytes;
        }

        // Struct @ codec.h:139:16
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct vorbis_comment
        {
            [FieldOffset(0)] // size = 8
            public CString* user_comments;

            [FieldOffset(8)] // size = 8
            public int* comment_lengths;

            [FieldOffset(16)] // size = 4
            public int comments;

            [FieldOffset(24)] // size = 8
            public CString vendor;
        }

        // Struct @ codec.h:409:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 464, Pack = 8)]
        public struct th_quant_info
        {
            [FieldOffset(0)] // size = 128
            public fixed byte _dc_scale[128]; // ogg_uint16_t[64]

            public Span<ogg_uint16_t> dc_scale
            {
                get
                {
                    fixed (th_quant_info* @this = &this)
                    {
                        var pointer = &@this->_dc_scale[0];
                        var span = new Span<ogg_uint16_t>(pointer, 64);
                        return span;
                    }
                }
            }

            [FieldOffset(128)] // size = 128
            public fixed byte _ac_scale[128]; // ogg_uint16_t[64]

            public Span<ogg_uint16_t> ac_scale
            {
                get
                {
                    fixed (th_quant_info* @this = &this)
                    {
                        var pointer = &@this->_ac_scale[0];
                        var span = new Span<ogg_uint16_t>(pointer, 64);
                        return span;
                    }
                }
            }

            [FieldOffset(256)] // size = 64
            public fixed byte _loop_filter_limits[64]; // unsigned char[64]

            public Span<byte> loop_filter_limits
            {
                get
                {
                    fixed (th_quant_info* @this = &this)
                    {
                        var pointer = &@this->_loop_filter_limits[0];
                        var span = new Span<byte>(pointer, 64);
                        return span;
                    }
                }
            }

            [FieldOffset(320)] // size = 144
            public fixed byte _qi_ranges[144]; // th_quant_ranges[2]

            public Span<th_quant_ranges> qi_ranges
            {
                get
                {
                    fixed (th_quant_info* @this = &this)
                    {
                        var pointer = &@this->_qi_ranges[0];
                        var span = new Span<th_quant_ranges>(pointer, 2);
                        return span;
                    }
                }
            }
        }

        // Struct @ ogg.h:27:9
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct ogg_iovec_t
        {
            [FieldOffset(0)] // size = 8
            public void* iov_base;

            [FieldOffset(8)] // size = 8
            public ulong iov_len;
        }

        // Struct @ codec.h:87:16
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 192, Pack = 8)]
        public struct vorbis_block
        {
            [FieldOffset(0)] // size = 8
            public double** pcm;

            [FieldOffset(8)] // size = 40
            public oggpack_buffer opb;

            [FieldOffset(48)] // size = 8
            public long lW;

            [FieldOffset(56)] // size = 8
            public long W;

            [FieldOffset(64)] // size = 8
            public long nW;

            [FieldOffset(72)] // size = 4
            public int pcmend;

            [FieldOffset(76)] // size = 4
            public int mode;

            [FieldOffset(80)] // size = 4
            public int eofflag;

            [FieldOffset(88)] // size = 8
            public ogg_int64_t granulepos;

            [FieldOffset(96)] // size = 8
            public ogg_int64_t sequence;

            [FieldOffset(104)] // size = 8
            public vorbis_dsp_state* vd;

            [FieldOffset(112)] // size = 8
            public void* localstore;

            [FieldOffset(120)] // size = 8
            public long localtop;

            [FieldOffset(128)] // size = 8
            public long localalloc;

            [FieldOffset(136)] // size = 8
            public long totaluse;

            [FieldOffset(144)] // size = 8
            public alloc_chain* reap;

            [FieldOffset(152)] // size = 8
            public long glue_bits;

            [FieldOffset(160)] // size = 8
            public long time_bits;

            [FieldOffset(168)] // size = 8
            public long floor_bits;

            [FieldOffset(176)] // size = 8
            public long res_bits;

            [FieldOffset(184)] // size = 8
            public void* @internal;
        }

        // Struct @ codec.h:323:16
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct th_comment
        {
            [FieldOffset(0)] // size = 8
            public CString* user_comments;

            [FieldOffset(8)] // size = 8
            public int* comment_lengths;

            [FieldOffset(16)] // size = 4
            public int comments;

            [FieldOffset(24)] // size = 8
            public CString vendor;
        }

        // Struct @ codec.h:126:8
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct alloc_chain
        {
            [FieldOffset(0)] // size = 8
            public void* ptr;

            [FieldOffset(8)] // size = 8
            public alloc_chain* next;
        }

        // Struct @ theoradec.h:142:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct th_stripe_callback
        {
            [FieldOffset(0)] // size = 8
            public void* ctx;

            [FieldOffset(8)] // size = 8
            public th_stripe_decoded_func stripe_decoded;
        }

        // Struct @ codec.h:204:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 64, Pack = 4)]
        public struct th_info
        {
            [FieldOffset(0)] // size = 1
            public byte version_major;

            [FieldOffset(1)] // size = 1
            public byte version_minor;

            [FieldOffset(2)] // size = 1
            public byte version_subminor;

            [FieldOffset(4)] // size = 4
            public ogg_uint32_t frame_width;

            [FieldOffset(8)] // size = 4
            public ogg_uint32_t frame_height;

            [FieldOffset(12)] // size = 4
            public ogg_uint32_t pic_width;

            [FieldOffset(16)] // size = 4
            public ogg_uint32_t pic_height;

            [FieldOffset(20)] // size = 4
            public ogg_uint32_t pic_x;

            [FieldOffset(24)] // size = 4
            public ogg_uint32_t pic_y;

            [FieldOffset(28)] // size = 4
            public ogg_uint32_t fps_numerator;

            [FieldOffset(32)] // size = 4
            public ogg_uint32_t fps_denominator;

            [FieldOffset(36)] // size = 4
            public ogg_uint32_t aspect_numerator;

            [FieldOffset(40)] // size = 4
            public ogg_uint32_t aspect_denominator;

            [FieldOffset(44)] // size = 4
            public th_colorspace colorspace;

            [FieldOffset(48)] // size = 4
            public th_pixel_fmt pixel_fmt;

            [FieldOffset(52)] // size = 4
            public int target_bitrate;

            [FieldOffset(56)] // size = 4
            public int quality;

            [FieldOffset(60)] // size = 4
            public int keyframe_granule_shift;
        }

        // Struct @ ogg.h:90:9
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [StructLayout(LayoutKind.Explicit, Size = 48, Pack = 8)]
        public struct ogg_packet
        {
            [FieldOffset(0)] // size = 8
            public byte* packet;

            [FieldOffset(8)] // size = 8
            public long bytes;

            [FieldOffset(16)] // size = 8
            public long b_o_s;

            [FieldOffset(24)] // size = 8
            public long e_o_s;

            [FieldOffset(32)] // size = 8
            public ogg_int64_t granulepos;

            [FieldOffset(40)] // size = 8
            public ogg_int64_t packetno;
        }

        // Struct @ theorafile.h:48:16
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct tf_callbacks
        {
            [FieldOffset(0)] // size = 8
            public FnPtr_VoidPtr_Ulong_Ulong_VoidPtr_Ulong read_func;

            [FieldOffset(8)] // size = 8
            public FnPtr_VoidPtr_Ogg_int64_t_Int_Int seek_func;

            [FieldOffset(16)] // size = 8
            public FnPtr_VoidPtr_Int close_func;
        }

        // Struct @ codec.h:438:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 4)]
        public struct th_huff_code
        {
            [FieldOffset(0)] // size = 4
            public ogg_uint32_t pattern;

            [FieldOffset(4)] // size = 4
            public int nbits;
        }

        // Struct @ ogg.h:32:9
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 8)]
        public struct oggpack_buffer
        {
            [FieldOffset(0)] // size = 8
            public long endbyte;

            [FieldOffset(8)] // size = 4
            public int endbit;

            [FieldOffset(16)] // size = 8
            public byte* buffer;

            [FieldOffset(24)] // size = 8
            public byte* ptr;

            [FieldOffset(32)] // size = 8
            public long storage;
        }

        // Struct @ ogg.h:53:9
        //	aarch64-apple-darwin (lib/ogg/ogg.h)
        //	x86_64-apple-darwin (lib/ogg/ogg.h)
        [StructLayout(LayoutKind.Explicit, Size = 408, Pack = 8)]
        public struct ogg_stream_state
        {
            [FieldOffset(0)] // size = 8
            public byte* body_data;

            [FieldOffset(8)] // size = 8
            public long body_storage;

            [FieldOffset(16)] // size = 8
            public long body_fill;

            [FieldOffset(24)] // size = 8
            public long body_returned;

            [FieldOffset(32)] // size = 8
            public int* lacing_vals;

            [FieldOffset(40)] // size = 8
            public ogg_int64_t* granule_vals;

            [FieldOffset(48)] // size = 8
            public long lacing_storage;

            [FieldOffset(56)] // size = 8
            public long lacing_fill;

            [FieldOffset(64)] // size = 8
            public long lacing_packet;

            [FieldOffset(72)] // size = 8
            public long lacing_returned;

            [FieldOffset(80)] // size = 282
            public fixed byte _header[282]; // unsigned char[282]

            public Span<byte> header
            {
                get
                {
                    fixed (ogg_stream_state* @this = &this)
                    {
                        var pointer = &@this->_header[0];
                        var span = new Span<byte>(pointer, 282);
                        return span;
                    }
                }
            }

            [FieldOffset(364)] // size = 4
            public int header_fill;

            [FieldOffset(368)] // size = 4
            public int e_o_s;

            [FieldOffset(372)] // size = 4
            public int b_o_s;

            [FieldOffset(376)] // size = 8
            public long serialno;

            [FieldOffset(384)] // size = 8
            public long pageno;

            [FieldOffset(392)] // size = 8
            public ogg_int64_t packetno;

            [FieldOffset(400)] // size = 8
            public ogg_int64_t granulepos;
        }

        // OpaqueType @ theoradec.h:166:30
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        [StructLayout(LayoutKind.Sequential)]
        public struct th_setup_info
        {
        }

        // OpaqueType @ theoradec.h:159:30
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        [StructLayout(LayoutKind.Sequential)]
        public struct th_dec_ctx
        {
        }

        // TypeAlias @ os_types.h:77:20
        //	aarch64-apple-darwin (lib/ogg/os_types.h)
        //	x86_64-apple-darwin (lib/ogg/os_types.h)
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct ogg_int64_t
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public long Data;

            public static implicit operator long(ogg_int64_t data) => data.Data;
            public static implicit operator ogg_int64_t(long data) => new() { Data = data };
        }

        // TypeAlias @ os_types.h:74:21
        //	aarch64-apple-darwin (lib/ogg/os_types.h)
        //	x86_64-apple-darwin (lib/ogg/os_types.h)
        [StructLayout(LayoutKind.Explicit, Size = 2, Pack = 2)]
        public struct ogg_uint16_t
        {
            [FieldOffset(0)] // size = 2, padding = 0
            public ushort Data;

            public static implicit operator ushort(ogg_uint16_t data) => data.Data;
            public static implicit operator ogg_uint16_t(ushort data) => new() { Data = data };
        }

        // TypeAlias @ theoradec.h:138:16
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct th_stripe_decoded_func
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Th_ycbcr_buffer_Int_Int_Void Data;

            public static implicit operator FnPtr_VoidPtr_Th_ycbcr_buffer_Int_Int_Void(th_stripe_decoded_func data) => data.Data;
            public static implicit operator th_stripe_decoded_func(FnPtr_VoidPtr_Th_ycbcr_buffer_Int_Int_Void data) => new() { Data = data };
        }

        // TypeAlias @ codec.h:338:23
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 64, Pack = 8)]
        public struct th_quant_base
        {
            [FieldOffset(0)] // size = 64, padding = 0
            public byte* Data;

            public static implicit operator byte*(th_quant_base data) => data.Data;
            public static implicit operator th_quant_base(byte* data) => new() { Data = data };
        }

        // TypeAlias @ os_types.h:76:21
        //	aarch64-apple-darwin (lib/ogg/os_types.h)
        //	x86_64-apple-darwin (lib/ogg/os_types.h)
        [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
        public struct ogg_uint32_t
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint Data;

            public static implicit operator uint(ogg_uint32_t data) => data.Data;
            public static implicit operator ogg_uint32_t(uint data) => new() { Data = data };
        }

        // TypeAlias @ codec.h:168:22
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        [StructLayout(LayoutKind.Explicit, Size = 72, Pack = 8)]
        public struct th_ycbcr_buffer
        {
            [FieldOffset(0)] // size = 72, padding = 0
            public th_img_plane* Data;

            public static implicit operator th_img_plane*(th_ycbcr_buffer data) => data.Data;
            public static implicit operator th_ycbcr_buffer(th_img_plane* data) => new() { Data = data };
        }

        // Enum @ codec.h:98:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public enum th_colorspace : int
        {
            TH_CS_UNSPECIFIED = 0,
            TH_CS_ITU_REC_470M = 1,
            TH_CS_ITU_REC_470BG = 2,
            TH_CS_NSPACES = 3
        }

        // Enum @ codec.h:114:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public enum th_pixel_fmt : int
        {
            TH_PF_420 = 0,
            TH_PF_RSVD = 1,
            TH_PF_422 = 2,
            TH_PF_444 = 3,
            TH_PF_NFORMATS = 4
        }

        // MacroObject @ codec.h:85:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public const int TH_EIMPL = -23;

        // MacroObject @ codec.h:81:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public const int TH_ENOTFORMAT = -21;

        // MacroObject @ codec.h:223:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_HOLE = -3;

        // MacroObject @ theoradec.h:98:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        public const int TH_DECCTL_SET_TELEMETRY_MV = 11;

        // MacroObject @ theoradec.h:102:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        public const int TH_DECCTL_SET_TELEMETRY_BITS = 15;

        // MacroObject @ codec.h:230:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_EBADHEADER = -133;

        // MacroObject @ codec.h:425:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public const int TH_NDCT_TOKENS = 32;

        // MacroObject @ codec.h:83:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public const int TH_EVERSION = -22;

        // MacroObject @ codec.h:228:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_EINVAL = -131;

        // MacroObject @ theorafile.h:97:9
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        public const int TF_EUNSUPPORTED = -2;

        // MacroObject @ codec.h:75:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public const int TH_EFAULT = -1;

        // MacroObject @ codec.h:222:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_EOF = -2;

        // MacroObject @ codec.h:235:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_ENOSEEK = -138;

        // MacroObject @ codec.h:91:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public const int TH_DUPFRAME = 1;

        // MacroObject @ theoradec.h:100:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        public const int TH_DECCTL_SET_TELEMETRY_QI = 13;

        // MacroObject @ codec.h:79:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public const int TH_EBADHEADER = -20;

        // MacroObject @ codec.h:229:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_ENOTVORBIS = -132;

        // MacroObject @ theoradec.h:50:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        public const int TH_DECCTL_GET_PPLEVEL_MAX = 1;

        // MacroObject @ codec.h:231:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_EVERSION = -134;

        // MacroObject @ codec.h:227:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_EIMPL = -130;

        // MacroObject @ theorafile.h:96:9
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        public const int TF_EUNKNOWN = -1;

        // MacroObject @ codec.h:226:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_EFAULT = -129;

        // MacroObject @ codec.h:221:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_FALSE = -1;

        // MacroObject @ theoradec.h:67:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        public const int TH_DECCTL_SET_PPLEVEL = 3;

        // MacroObject @ codec.h:423:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public const int TH_NHUFFMAN_TABLES = 80;

        // MacroObject @ codec.h:77:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public const int TH_EINVAL = -10;

        // MacroObject @ codec.h:87:9
        //	aarch64-apple-darwin (lib/theora/codec.h)
        //	x86_64-apple-darwin (lib/theora/codec.h)
        public const int TH_EBADPACKET = -24;

        // MacroObject @ codec.h:232:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_ENOTAUDIO = -135;

        // MacroObject @ theoradec.h:79:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        public const int TH_DECCTL_SET_GRANPOS = 5;

        // MacroObject @ theoradec.h:93:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        public const int TH_DECCTL_SET_STRIPE_CB = 7;

        // MacroObject @ theorafile.h:98:9
        //	aarch64-apple-darwin
        //	x86_64-apple-darwin
        public const int TF_ENODATASOURCE = -3;

        // MacroObject @ codec.h:233:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_EBADPACKET = -136;

        // MacroObject @ theoradec.h:96:9
        //	aarch64-apple-darwin (lib/theora/theoradec.h)
        //	x86_64-apple-darwin (lib/theora/theoradec.h)
        public const int TH_DECCTL_SET_TELEMETRY_MBMODE = 9;

        // MacroObject @ codec.h:225:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_EREAD = -128;

        // MacroObject @ codec.h:234:9
        //	aarch64-apple-darwin (lib/vorbis/codec.h)
        //	x86_64-apple-darwin (lib/vorbis/codec.h)
        public const int OV_EBADLINK = -137;

        #endregion

        #region Setup & Teardown

        public static void Setup()
        {
            PreCompile();
        }

        private static void PreCompile()
        {
            var methods = typeof(Theorafile).GetMethods(
                System.Reflection.BindingFlags.DeclaredOnly |
                System.Reflection.BindingFlags.NonPublic |
                System.Reflection.BindingFlags.Public |
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.Static);

            foreach (var method in methods)
            {
                if (method.GetMethodBody() == null)
                {
                    RuntimeHelpers.PrepareMethod(method.MethodHandle);
                }
            }
        }

        public static void Teardown()
        {
        }

        #endregion

        #region Runtime

        public static class Runtime
        {

            /// <summary>
            ///     A boolean value type with the same memory layout as a <see cref="byte" /> in both managed and unmanaged contexts;
            ///     equivalent to a standard bool found in C/C++/ObjC where <c>0</c> is <c>false</c> and any other value is
            ///     <c>true</c>.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CBool : IEquatable<CBool>
            {
                private readonly byte _value;

                private CBool(bool value)
                {
                    _value = Convert.ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CBool" />.</returns>
                public static implicit operator CBool(bool value)
                {
                    return FromBoolean(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CBool" />.</returns>
                public static CBool FromBoolean(bool value)
                {
                    return new CBool(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="bool" />.</returns>
                public static implicit operator bool(CBool value)
                {
                    return ToBoolean(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="bool" />.</returns>
                public static bool ToBoolean(CBool value)
                {
                    return Convert.ToBoolean(value._value);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return ToBoolean(this).ToString();
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CBool b && Equals(b);
                }

                /// <inheritdoc />
                public bool Equals(CBool other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CBool left, CBool right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CBool left, CBool right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CBool left, CBool right)
                {
                    return left._value == right._value;
                }
            }

            /// <summary>
            ///     A value type with the same memory layout as a <see cref="byte" /> in a managed context and <c>char</c> in
            ///     an unmanaged context.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CChar : IEquatable<byte>, IEquatable<CChar>
            {
                private readonly byte _value;

                private CChar(byte value)
                {
                    _value = Convert.ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CChar" />.</returns>
                public static implicit operator CChar(byte value)
                {
                    return FromByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CChar" />.</returns>
                public static CChar FromByte(byte value)
                {
                    return new CChar(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="byte" />.</returns>
                public static implicit operator byte(CChar value)
                {
                    return ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="byte" />.</returns>
                public static byte ToByte(CChar value)
                {
                    return value._value;
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return _value.ToString(CultureInfo.InvariantCulture);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CChar value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(byte other)
                {
                    return _value == other;
                }

                /// <inheritdoc />
                public bool Equals(CChar other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CChar left, CChar right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CChar left, CChar right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CChar left, CChar right)
                {
                    return left._value == right._value;
                }
            }

#pragma warning disable CS1591

            /// <summary>
            ///     Utility methods for dealing with native C libraries.
            /// </summary>
            public static class CLibrary
            {
                /// <summary>
                ///     Loads a C shared library (`.dll`/`.dylib`/`.so`) into the application's memory space given the C
                ///     library's file name, partially qualified file path, or a fully qualified file path.
                /// </summary>
                /// <param name="name">The C library's file name, partially qualified file path, or a fully qualified file path.</param>
                /// <returns>A <see cref="IntPtr" /> handle if the C library was loaded; otherwise, a <see cref="IntPtr.Zero" /> handle.</returns>
                /// <remarks>
                ///     <para>
                ///         If the library was already loaded, calling <see cref="Load" /> returns the handle of the previous loaded
                ///         library and the reference count for the handle is incremented.
                ///     </para>
                ///     <para>You must call <see cref="Free" /> when finished using a handle of a dynamically loaded library.</para>
                /// </remarks>
                public static IntPtr Load(string name)
                {
                    if (IsLinux)
                    {
                        return libdl.dlopen(name, 0x101); // RTLD_GLOBAL | RTLD_LAZY
                    }

                    if (IsWindows)
                    {
                        return Kernel32.LoadLibrary(name);
                    }

                    if (IsDarwin)
                    {
                        return libSystem.dlopen(name, 0x101); // RTLD_GLOBAL | RTLD_LAZY
                    }

                    return IntPtr.Zero;
                }

                /// <summary>
                ///     Unloads a C shared library from the application's memory space given the library's handle.
                /// </summary>
                /// <param name="handle">The library's handle previously created by calling <see cref="Load" />.</param>
                /// <remarks>
                ///     <para>
                ///         If the library was loaded multiple times, the reference count for the handle is decremented upon calling
                ///         <see cref="Free" /> and the library is not yet unloaded from memory.
                ///     </para>
                /// </remarks>
                public static void Free(IntPtr handle)
                {
                    if (IsLinux)
                    {
                        libdl.dlclose(handle);
                    }

                    if (IsWindows)
                    {
                        Kernel32.FreeLibrary(handle);
                    }

                    if (IsDarwin)
                    {
                        libSystem.dlclose(handle);
                    }
                }

                public static IntPtr GetExport(IntPtr handle, string symbolName)
                {
                    if (IsLinux)
                    {
                        return libdl.dlsym(handle, symbolName);
                    }

                    if (IsWindows)
                    {
                        return Kernel32.GetProcAddress(handle, symbolName);
                    }

                    if (IsDarwin)
                    {
                        return libSystem.dlsym(handle, symbolName);
                    }

                    return IntPtr.Zero;
                }

                private static bool IsWindows
                {
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    get =>
#if NET5_0_OR_GREATER
            OperatingSystem.IsWindows();
#elif NETFRAMEWORK || NETSTANDARD || NETCOREAPP
            RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
#else
            false;
#endif
                }

                private static bool IsDarwin
                {
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    get =>
#if NET5_0_OR_GREATER
            OperatingSystem.IsMacOS() || 
            OperatingSystem.IsMacCatalyst() ||
            OperatingSystem.IsIOS() || 
            OperatingSystem.IsTvOS() ||
            OperatingSystem.IsWatchOS();
#elif NETFRAMEWORK || NETSTANDARD || NETCOREAPP
            RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
#else
            false;
#endif
                }

                private static bool IsLinux
                {
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    get =>
#if NET5_0_OR_GREATER
            OperatingSystem.IsLinux() ||
            OperatingSystem.IsFreeBSD() ||
            OperatingSystem.IsAndroid();
#elif NETFRAMEWORK || NETSTANDARD || NETCOREAPP
            RuntimeInformation.IsOSPlatform(OSPlatform.Linux);
#else
            false;
#endif
                }

                [System.Security.SuppressUnmanagedCodeSecurity]
                private static class libdl
                {
                    private const string LibraryName = "libdl";

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
                    public static extern IntPtr dlopen(string fileName, int flags);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
                    public static extern IntPtr dlsym(IntPtr handle, string name);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall)]
                    public static extern int dlclose(IntPtr handle);
                }

                [System.Security.SuppressUnmanagedCodeSecurity]
                private static class libSystem
                {
                    private const string LibraryName = "libSystem";

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
                    public static extern IntPtr dlopen(string fileName, int flags);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
                    public static extern IntPtr dlsym(IntPtr handle, string name);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall)]
                    public static extern int dlclose(IntPtr handle);
                }

                [System.Security.SuppressUnmanagedCodeSecurity]
                private static class Kernel32
                {
                    private const string LibraryName = "kernel32";

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi,
                        ExactSpelling = true, SetLastError = true)]
                    public static extern IntPtr LoadLibrary(string fileName);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi,
                        ExactSpelling = true, SetLastError = true)]
                    public static extern IntPtr GetProcAddress(IntPtr module, string procName);

                    [DllImport(LibraryName, CallingConvention = CallingConvention.StdCall, SetLastError = true)]
                    public static extern int FreeLibrary(IntPtr module);
                }
            }

            /// <summary>
            ///     A pointer value type of bytes that represent a string; the C type `char*`.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly unsafe struct CString : IEquatable<CString>
            {
                internal readonly nint _pointer;

                /// <summary>
                ///     Gets a value indicating whether this <see cref="CString" /> is a null pointer.
                /// </summary>
                public bool IsNull => _pointer == 0;

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CString(byte* value)
                {
                    _pointer = (nint)value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CString(nint value)
                {
                    _pointer = value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="s">The string value.</param>
                public CString(string s)
                {
                    _pointer = CStrings.CString(s);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static explicit operator CString(nint value)
                {
                    return FromIntPtr(value);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString FromIntPtr(nint value)
                {
                    return new CString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static implicit operator CString(byte* value)
                {
                    return From(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString From(byte* value)
                {
                    return new CString((nint)value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static implicit operator nint(CString value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static nint ToIntPtr(CString value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CString" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static implicit operator string(CString value)
                {
                    return ToString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CString" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static string ToString(CString value)
                {
                    return CStrings.String(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static implicit operator CString(string s)
                {
                    return FromString(s);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString FromString(string s)
                {
                    return CStrings.CString(s);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return CStrings.String(this);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CString value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CString other)
                {
                    return _pointer == other._pointer;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _pointer.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CString left, CString right)
                {
                    return left._pointer == right._pointer;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CString left, CString right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CString left, CString right)
                {
                    return left._pointer == right._pointer;
                }
            }

            /// <summary>
            ///     Utility methods for interoperability with C style strings in C#.
            /// </summary>
            public static unsafe class CStrings
            {
                private static readonly Dictionary<uint, CString> StringHashesToPointers = new();
                private static readonly Dictionary<nint, string> PointersToStrings = new();
                private static readonly Dictionary<uint, CStringWide> StringHashesToPointersWide = new();
                private static readonly Dictionary<nint, string> PointersToStringsWide = new();

                /// <summary>
                ///     Converts a C style string (ANSI or UTF-8) of type `char` (one dimensional byte array
                ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="value">A pointer to the C string.</param>
                /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
                public static string String(CString value)
                {
                    if (value.IsNull)
                    {
                        return string.Empty;
                    }

                    if (PointersToStrings.TryGetValue(value._pointer, out var result))
                    {
                        return result;
                    }

                    var hash = Djb2((byte*)value._pointer);
                    if (StringHashesToPointers.TryGetValue(hash, out var pointer2))
                    {
                        result = PointersToStrings[pointer2._pointer];
                        return result;
                    }

                    // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                    // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                    result = Marshal.PtrToStringAnsi(value._pointer);

                    if (string.IsNullOrEmpty(result))
                    {
                        return string.Empty;
                    }

                    StringHashesToPointers.Add(hash, value);
                    PointersToStrings.Add(value._pointer, result);

                    return result;
                }

                /// <summary>
                ///     Converts a C style string (unicode) of type `wchar_t` (one dimensional ushort array
                ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="value">A pointer to the C string.</param>
                /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
                public static string StringWide(CStringWide value)
                {
                    if (value.IsNull)
                    {
                        return string.Empty;
                    }

                    if (PointersToStringsWide.TryGetValue(value._pointer, out var result))
                    {
                        return result;
                    }

                    var hash = Djb2((byte*)value._pointer);
                    if (StringHashesToPointersWide.TryGetValue(hash, out var pointer2))
                    {
                        result = PointersToStringsWide[pointer2._pointer];
                        return result;
                    }

                    // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                    // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                    result = Marshal.PtrToStringUni(pointer2._pointer);

                    if (string.IsNullOrEmpty(result))
                    {
                        return string.Empty;
                    }

                    StringHashesToPointersWide.Add(hash, value);
                    PointersToStringsWide.Add(value._pointer, result);

                    return result;
                }

                /// <summary>
                ///     Converts a UTF-16 <see cref="string" /> to a C style string (one dimensional byte array terminated by a
                ///     <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <param name="str">The <see cref="string" />.</param>
                /// <returns>A C string pointer.</returns>
                public static CString CString(string str)
                {
                    var hash = Djb2(str);
                    if (StringHashesToPointers.TryGetValue(hash, out var r))
                    {
                        return r;
                    }

                    // ReSharper disable once JoinDeclarationAndInitializer
                    var pointer = Marshal.StringToHGlobalAnsi(str);
                    StringHashesToPointers.Add(hash, new CString(pointer));
                    PointersToStrings.Add(pointer, str);

                    return new CString(pointer);
                }

                /// <summary>
                ///     Converts a C string pointer (one dimensional byte array terminated by a
                ///     <c>0x0</c>) for a specified <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="str">The <see cref="string" />.</param>
                /// <returns>A C string pointer.</returns>
                public static CStringWide CStringWide(string str)
                {
                    var hash = Djb2(str);
                    if (StringHashesToPointersWide.TryGetValue(hash, out var r))
                    {
                        return r;
                    }

                    // ReSharper disable once JoinDeclarationAndInitializer
                    var pointer = Marshal.StringToHGlobalUni(str);
                    StringHashesToPointersWide.Add(hash, new CStringWide(pointer));
                    PointersToStringsWide.Add(pointer, str);

                    return new CStringWide(pointer);
                }

                /// <summary>
                ///     Converts an array of strings to an array of C strings of type `char` (multi-dimensional array of one
                ///     dimensional byte arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <remarks>
                ///     <para>Calls <see cref="CString" />.</para>
                /// </remarks>
                /// <param name="values">The strings.</param>
                /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
                public static CString* CStringArray(ReadOnlySpan<string> values)
                {
                    var pointerSize = IntPtr.Size;
                    var result = (CString*)Marshal.AllocHGlobal(pointerSize * values.Length);
                    for (var i = 0; i < values.Length; ++i)
                    {
                        var @string = values[i];
                        var cString = CString(@string);
                        result[i] = cString;
                    }

                    return result;
                }

                /// <summary>
                ///     Converts an array of strings to an array of C strings of type `wchar_t` (multi-dimensional array of one
                ///     dimensional ushort arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <remarks>
                ///     <para>Calls <see cref="CString" />.</para>
                /// </remarks>
                /// <param name="values">The strings.</param>
                /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
                public static CStringWide* CStringWideArray(ReadOnlySpan<string> values)
                {
                    var pointerSize = IntPtr.Size;
                    var result = (CStringWide*)Marshal.AllocHGlobal(pointerSize * values.Length);
                    for (var i = 0; i < values.Length; ++i)
                    {
                        var @string = values[i];
                        var cString = CStringWide(@string);
                        result[i] = cString;
                    }

                    return result;
                }

                /// <summary>
                ///     Frees the memory for all previously allocated C strings and releases references to all <see cref="string" />
                ///     objects which happened during <see cref="String" />, <see cref="StringWide" />, <see cref="CString" />
                ///     or <see cref="CStringWide" />. Does <b>not</b> garbage collect.
                /// </summary>
                public static void FreeAllStrings()
                {
                    foreach (var (ptr, _) in PointersToStrings)
                    {
                        Marshal.FreeHGlobal(ptr);
                    }

                    // We can not guarantee that the application has not a strong reference the string since it was allocated,
                    //  so we have to let the GC take the wheel here. Thus, this method should NOT garbage collect; that's
                    //  on the responsibility of the application developer. The best we can do is just remove any and all strong
                    //  references we have here to the strings.

                    StringHashesToPointers.Clear();
                    PointersToStrings.Clear();
                }

                /// <summary>
                ///     Frees the memory for specific previously allocated C strings and releases associated references to
                ///     <see cref="string" /> objects which happened during <see cref="String" /> or
                ///     <see cref="CString" />. Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="pointers">The C string pointers.</param>
                /// <param name="count">The number of C string pointers.</param>
                public static void FreeCStrings(CString* pointers, int count)
                {
                    for (var i = 0; i < count; i++)
                    {
                        var ptr = pointers[i];
                        FreeCString(ptr);
                    }

                    Marshal.FreeHGlobal((IntPtr)pointers);
                }

                /// <summary>
                ///     Frees the memory for the previously allocated C string and releases reference to the
                ///     <see cref="string" /> object which happened during <see cref="String" /> or <see cref="CString" />.
                ///     Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="value">The string.</param>
                public static void FreeCString(CString value)
                {
                    if (!PointersToStrings.ContainsKey(value._pointer))
                    {
                        return;
                    }

                    Marshal.FreeHGlobal(value);
                    var hash = Djb2(value);
                    StringHashesToPointers.Remove(hash);
                    PointersToStrings.Remove(value._pointer);
                }

                /// <summary>
                ///     Frees the memory for the previously allocated C string and releases reference to the
                ///     <see cref="string" /> object which happened during <see cref="StringWide" /> or <see cref="CStringWide" />.
                ///     Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="value">The string.</param>
                public static void FreeCStringWide(CStringWide value)
                {
                    if (!PointersToStringsWide.ContainsKey(value._pointer))
                    {
                        return;
                    }

                    Marshal.FreeHGlobal(value);
                    var hash = Djb2(value);
                    StringHashesToPointersWide.Remove(hash);
                    PointersToStringsWide.Remove(value._pointer);
                }

                // djb2 is named after https://en.wikipedia.org/wiki/Daniel_J._Bernstein
                //  References:
                //  (1) https://stackoverflow.com/a/7666577/2171957
                //  (2) http://www.cse.yorku.ca/~oz/hash.html
                //  (3) https://groups.google.com/g/comp.lang.c/c/lSKWXiuNOAk/m/zstZ3SRhCjgJ
                private static uint Djb2(byte* str)
                {
                    uint hash = 5381;

                    unchecked
                    {
                        uint c;
                        while ((c = *str++) != 0)
                        {
                            hash = (hash << 5) + hash + c; // hash * 33 + c
                        }
                    }

                    return hash;
                }

                private static uint Djb2(string str)
                {
                    uint hash = 5381;

                    // ReSharper disable once ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
                    foreach (var c in str)
                    {
                        hash = (hash << 5) + hash + c; // hash * 33 + c
                    }

                    return hash;
                }
            }

            /// <summary>
            ///     A pointer value type that represents a wide string; C type `wchar_t*`.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly unsafe struct CStringWide : IEquatable<CStringWide>
            {
                internal readonly nint _pointer;

                /// <summary>
                ///     Gets a value indicating whether this <see cref="CStringWide" /> is a null pointer.
                /// </summary>
                public bool IsNull => _pointer == 0;

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CStringWide(byte* value)
                {
                    _pointer = (nint)value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CStringWide(nint value)
                {
                    _pointer = value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="s">The string value.</param>
                public CStringWide(string s)
                {
                    _pointer = CStrings.CStringWide(s);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static explicit operator CStringWide(nint value)
                {
                    return FromIntPtr(value);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide FromIntPtr(nint value)
                {
                    return new CStringWide(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static implicit operator CStringWide(byte* value)
                {
                    return From(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide From(byte* value)
                {
                    return new CStringWide((nint)value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static implicit operator nint(CStringWide value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static nint ToIntPtr(CStringWide value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CStringWide" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static implicit operator string(CStringWide value)
                {
                    return ToString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CStringWide" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static string ToString(CStringWide value)
                {
                    return CStrings.StringWide(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static implicit operator CStringWide(string s)
                {
                    return FromString(s);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide FromString(string s)
                {
                    return CStrings.CStringWide(s);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return CStrings.StringWide(this);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CStringWide value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CStringWide other)
                {
                    return _pointer == other._pointer;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _pointer.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CStringWide left, CStringWide right)
                {
                    return left._pointer == right._pointer;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CStringWide left, CStringWide right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CStringWide left, CStringWide right)
                {
                    return left._pointer == right._pointer;
                }
            }
        }

        #endregion
    }
}